"use strict";
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const botframework_schema_1 = require("botframework-schema");
const turnContext_1 = require("./turnContext");
/**
 * Logs incoming and outgoing activities to a TranscriptStore.
 */
class TranscriptLoggerMiddleware {
    /**
     * Middleware for logging incoming and outgoing activities to a transcript store.
     * @param logger Transcript logger
     */
    constructor(logger) {
        if (!logger) {
            throw new Error('TranscriptLoggerMiddleware requires a TranscriptLogger instance.');
        }
        this.logger = logger;
    }
    /**
     * Initialization for middleware turn.
     * @param context Context for the current turn of conversation with the user.
     * @param next Function to call at the end of the middleware chain.
     */
    async onTurn(context, next) {
        let transcript = [];
        // log incoming activity at beginning of turn
        if (context.activity) {
            if (!context.activity.from.role) {
                context.activity.from.role = 'user';
            }
            this.logActivity(transcript, this.cloneActivity(context.activity));
        }
        // hook up onSend pipeline
        context.onSendActivities(async (ctx, activities, next2) => {
            // run full pipeline
            const responses = await next2();
            activities.forEach((a) => this.logActivity(transcript, this.cloneActivity(a)));
            return responses;
        });
        // hook up update activity pipeline
        context.onUpdateActivity(async (ctx, activity, next3) => {
            // run full pipeline
            const response = await next3();
            // add Message Update activity
            const updateActivity = this.cloneActivity(activity);
            updateActivity.type = botframework_schema_1.ActivityTypes.MessageUpdate;
            this.logActivity(transcript, updateActivity);
            return response;
        });
        // hook up delete activity pipeline
        context.onDeleteActivity(async (ctx, reference, next4) => {
            // run full pipeline
            await next4();
            // add MessageDelete activity
            // log as MessageDelete activity
            const deleteActivity = turnContext_1.TurnContext.applyConversationReference({
                type: botframework_schema_1.ActivityTypes.MessageDelete,
                id: reference.activityId
            }, reference, false);
            this.logActivity(transcript, deleteActivity);
        });
        // process bot logic
        await next();
        // flush transcript at end of turn
        while (transcript.length > 0) {
            try {
                const activity = transcript.shift();
                // If the implementation of this.logger.logActivity() is asynchronous, we don't
                // await it as to not block processing of activities.
                // Because TranscriptLogger.logActivity() returns void or Promise<void>, we capture
                // the result and see if it is a Promise.
                const logActivityResult = this.logger.logActivity(activity);
                // If this.logger.logActivity() returns a Promise, a catch is added in case there
                // is no innate error handling in the method. This catch prevents
                // UnhandledPromiseRejectionWarnings from being thrown and prints the error to the
                // console.
                if (logActivityResult instanceof Promise) {
                    logActivityResult.catch(err => {
                        this.transcriptLoggerErrorHandler(err);
                    });
                }
            }
            catch (err) {
                this.transcriptLoggerErrorHandler(err);
            }
        }
    }
    /**
     * Logs the Activity.
     * @param activity Activity to log.
     */
    logActivity(transcript, activity) {
        if (!activity.timestamp) {
            activity.timestamp = new Date();
        }
        transcript.push(activity);
    }
    /**
     * Clones the Activity entity.
     * @param activity Activity to clone.
     */
    cloneActivity(activity) {
        return Object.assign({}, activity);
    }
    /**
     * Error logging helper function.
     * @param err Error or object to console.error out.
     */
    transcriptLoggerErrorHandler(err) {
        // tslint:disable:no-console
        if (err instanceof Error) {
            console.error(`TranscriptLoggerMiddleware logActivity failed: "${err.message}"`);
            console.error(err.stack);
        }
        else {
            console.error(`TranscriptLoggerMiddleware logActivity failed: "${JSON.stringify(err)}"`);
        }
        // tslint:enable:no-console
    }
}
exports.TranscriptLoggerMiddleware = TranscriptLoggerMiddleware;
/**
 * ConsoleTranscriptLogger , writes activities to Console output.
 */
class ConsoleTranscriptLogger {
    /**
     * Log an activity to the transcript.
     * @param activity Activity being logged.
     */
    logActivity(activity) {
        if (!activity) {
            throw new Error('Activity is required.');
        }
        // tslint:disable-next-line:no-console
        console.log('Activity Log:', activity);
    }
}
exports.ConsoleTranscriptLogger = ConsoleTranscriptLogger;
//# sourceMappingURL=transcriptLogger.js.map